In your fourth and the final homework assignment you will solidify the knowledge of lambda-calculus by designing and implementing an untyped lambda-calculus interpreter. Your goal is to gain experience with the fundamentals of the functional programming languages and to understand reduction and conversion rules of the lambda calculus. You will implement your lambda interpreter in Scala and you will build and RUN your project using the SBT with the runMain command from the command line. In your lambda interpreter, you will use the reserved keyword lambda for designating the Greek letter lambda. You will define the rules for creating valid names (e.g., what characters they can contain, can the names start with a digit) using a regular expression. You will use the latest community version of IntelliJ IDE for this assignment.

WARNING: there are several implementations of lambda-calculus in Scala on the Internet. I know about (almost) all of them. You are ok to learn by studying these implementations and feel free to use the ideas in your own implementation, and you must acknowledge what you used in your README. However, blindly copying large parts of some existing implementation in your code will result in receiving the grade F for the entire course with the transfer of your case of plagiarism to the Dean of Students Office, which will be followed with severe penalties. Most likely, you will be suspended or complete dismissed from the program in the worst case. Please do not plagiarize existing implementations, it is not worth it!

The input to your interpreter is a lambda expression (e.g., (lambda x.(lambda y.(x y))3)square). Your interpreter will show a command line prompt and it will wait for a lambda expression. Once entered, the interpreter will parse the input lambda expression and output the derivations with all intermediate steps. For example, for the expression (lambda x.(lambda y.(x y))3)square the output may look like the following: (lambda x.(lambda y.(x y))3)square => substituting square for x: (lambda y.(square y))3 => substituting 3 for y: (square 3) => no further reduction is possible: (square 3). To handle infinite recursion, like in the case of self-application function, you must determine if a derivation results in a lambda expression that appeared already in a previous derivation and it will be the final output derivation. The output should specify what type of conversion your interpreter is applying (i.e., alpha, beta, eta). You will have a debugging or a verbose mode (with the -d or -v option for your interpreter), in which the interpreter will output additional information about all bound and free names, the order of evaluation, and all additional information that you may find relevant to the users. Error messages should be informative and descriptive (e.g., "malformed lambda expression: closing parentheses do not match opening parentheses").

For an additional bonus (up to 5%!) you need to implement an extended language where you can assign lambda expressions to variables (e.g., myvar = (lambda y.(x y)) and constval = 3) and then use these variables in other lambda expressions (e.g., (lambda x.(myvar constval)square)). Your implementation may take the input from the command line and determine whether the entered expression is an assignment or a lambda expression that should be evaluated. Your interpreter will compute the closure by locating these defined variables in your environment and substituting them into a lambda expression when evaluating it. To impress me even further, you can introduce static and dynamic scopes and implement dynamic scoping resolution when evaluating lambda expressions. Your additional bonus will be based on how you extend the base lambda calculus to handle different types of scopes in general, not on hardcoding a few special cases.

This is an individual homework. It differs from the previous homework 3, since you are NOT allowed to form groups. If you submitted your previous homeworks, it means that you were already added as a member of UIC_CS474_2016 team in Bitbucket. Separate repositories will be created for each of your homeworks and for the course project. You will find a corresponding entry for this homework. You will fork this repository and your fork will be private, no one else besides you, the TA and your course instructor will have access to your fork. Please remember to grant a read access to your repository to your TA and your instructor. You can commit and push your code as many times as you want. Your code will not be visible and it should not be visible to other students. When you push your project, your instructor and the TA will see you code in your separate private fork. Making your fork public or inviting other students to join your fork will result in losing your grade. For grading, only the latest push timed before the deadline will be considered. If you push after the deadline, your grade for the homework will be zero. For more information about using git and bitbucket specifically, please use this link as the starting point https://confluence.atlassian.com/bitbucket/bitbucket-cloud-documentation-home-221448814.html. For those of you who still struggle with Git, I keep recommending a book by Ryan Hodson on Ry's Git Tutorial. The other book called Pro Git is written by Scott Chacon and Ben Straub and published by Apress and it is freely available https://git-scm.com/book/en/v2/. There are multiple videos on youtube that go into details of Git organization and use.

As your TA specified, please follow this naming convention while submitting your work : "Firstname_Lastname_hw4", so that we can easily recognize your submission. I repeat, please make sure that you will give both your TA and me read access to your private forked repository.

As usual, I allow you to post questions and replies, statements, comments, discussion, etc. on Piazza either using your real names or anonymously. Remember that you cannot share *your* code and your solutions, but you can ask and advise others using Piazza on where resources and sample programs can be found on the internet, how to resolve dependencies and configuration issues, and how to design the logic of the algorithm, as usual. Yet, your implementation should be your own and you cannot share it. Alternatively, you cannot copy and paste someone else's implementation and put your name on it. As I mentioned above, your submissions will be checked for plagiarism. When posting question and answers on Piazza, please select the appropriate folder, i.e., hw4 to ensure that all discussion threads can be easily located.

Submission deadline: Monday, November 14 at 6AM CST. Your submission will include your source code, the SBT build configuration, the README.md file in the root directory that contains the description of your implementation, how to compile and run it using SBT, and what are the limitations of your implementation.

THE INSTRUCTOR AND THE TA WILL NOT ANSWER ANY REQUESTS FROM STUDENTS STARTING 7PM THE NIGHT BEFORE THE SUBMISSION DEADLINE.

Evaluation criteria:
- the maximum grade for this homework is 7% + up to 5% bonus. Points are subtracted from this maximum grade: for example, saying that 2% is lost if some requirement is not completed means that the resulting grade will be 7%-2% => 4%;
- no comments or highly insufficient comments: up to 2% lost;
- no unit and integration tests: up to 5% lost;
- code does not compile or it crashes without completing the core functionality: up to 5% lost;
- the documentation is missing or insufficient to understand how to compile and run your program: up to 6% lost;
- only a subset of your tests works: up to 3% lost;
- the minimum grade for this homework cannot be less than zero.